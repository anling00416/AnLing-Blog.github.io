<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>promise的学习笔记</title>
      <link href="/2023/09/26/promise%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/26/promise%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>  &#x2F;&#x2F; promise是一个构造函数，参数是一个函数，函数里面有俩个形参，一个是 resolve解决,reject拒绝，俩个都是函数类型的数据，promise可以包裹一个异步操作<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// promise是一个构造函数，参数是一个函数，函数里面有俩个形参，一个是 resolve解决,reject拒绝，俩个都是函数类型的数据，promise可以包裹一个异步操作</span></span><br><span class="line">        <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        )</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="promise常用API"><a href="#promise常用API" class="headerlink" title="promise常用API"></a>promise常用API</h2><p>  then 接下来(指定回调)<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//调用 then </span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  chach 捕获（捕获失败的方法，并可以接受一个形参）<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// ** 同步调用</span></span><br><span class="line">         <span class="comment">// console.log(111);</span></span><br><span class="line">         <span class="comment">//修改 promise 对象的状态</span></span><br><span class="line">         <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// console.log(222);</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//执行 catch 方法</span></span><br><span class="line">     <span class="comment">// p.catch(reason =&gt; &#123;</span></span><br><span class="line">     <span class="comment">//     console.log(reason);</span></span><br><span class="line">     <span class="comment">// &#125;);</span></span><br><span class="line">     <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure><br>  resolve 成功(  &#x2F;&#x2F;如果传入的参数为 非Promise类型的对象,<br>  则返回的结果为成功promise对象<br>  &#x2F;&#x2F;如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">521</span>);</span><br><span class="line">  <span class="comment">//如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象</span></span><br><span class="line">  <span class="comment">//如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果</span></span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="comment">// console.log(p2);</span></span><br><span class="line">  p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>  reject 失败</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   作用：放回一个失败的原因</span></span><br><span class="line"><span class="comment">//   特点：无轮传入一个什么值，返回的都是一个失败的Promise</span></span><br><span class="line">  <span class="comment">// let p = Promise.reject(521);</span></span><br><span class="line">        <span class="comment">// let p2 = Promise.reject(&#x27;iloveyou&#x27;);</span></span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(p3);    </span><br></pre></td></tr></table></figure><p>  Promise.all方法<br>  作用：返回一个新的promise，全真则真，一假既假</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="comment">// let p2 = Promise.resolve(&#x27;Success&#x27;);</span></span><br><span class="line">     <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>  Promise.race（竞赛）方法<br>  说明：放回一个新的promise，第一个完成的promise的结果状态就是他最终的结果<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">         &#125;, <span class="number">1000</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调用</span></span><br><span class="line">     <span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></p><h2 id="Promise几个关键问题"><a href="#Promise几个关键问题" class="headerlink" title="Promise几个关键问题"></a>Promise几个关键问题</h2><p>  修改Promise的状态有几种方式<br>  三种方式<br>  在构造函数中直接调用 resolve 函数<br>  在构造函数中直接调用 reject 函数<br>  在构造函数中直接抛出错误：throw Error<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//1. resolve 函数</span></span><br><span class="line">         <span class="comment">// resolve(&#x27;ok&#x27;); // pending   =&gt; fulfilled (resolved)</span></span><br><span class="line">         <span class="comment">//2. reject 函数</span></span><br><span class="line">         <span class="comment">// reject(&quot;error&quot;);// pending  =&gt;  rejected </span></span><br><span class="line">         <span class="comment">//3. 抛出错误</span></span><br><span class="line">         <span class="comment">// throw &#x27;出问题了&#x27;;</span></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure></p><p>  一个Promise指定多个成功&#x2F;失败的回调函数，都会调用吗？<br>    都会执行！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///指定回调 - 1</span></span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定回调 - 2</span></span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(value);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>改变Promise状态和指定回调函数谁先谁后<br>问题简化：Promise代码运行时，resolve先执行还是then先执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种情况都有可能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先改状态再指定回调：</span></span><br><span class="line"><span class="comment">// 执行器中是一个同步操作，那么就先做执行器中的操作再执行then语句即指定回调</span></span><br><span class="line"><span class="comment">// 例如直接在执行器中直接调用 resolve()/reject()</span></span><br><span class="line"><span class="comment">// 执行器中式一个异步操作，延长更长时间才调用then()同样可以达到效果</span></span><br><span class="line"><span class="comment">// 先指定回调再改变状态</span></span><br><span class="line"><span class="comment">// 执行器中式异步操作时，会先执行then，指定回调（但是不执行回调），再回头根据异步操作的顺序进行处理</span></span><br><span class="line"><span class="comment">// 什么时候能够得到数据？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果先改变状态，那么当指定回调时，回调函数就会被调用，得到数据</span></span><br><span class="line"><span class="comment">// 如果先指定回调，那么当状态发生改变时，回调函数才被调用得到数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p> then()方法返回的Promise的对象的状态由什么决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">简单表达：<span class="title function_">then</span>()方法返回的<span class="title class_">Promise</span>的对象的状态由什么决定</span><br><span class="line"></span><br><span class="line">如果回调函数抛出异常，返回<span class="title class_">Promise</span>状态为【rejected】</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line">       ),<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">       &#125;);</span><br><span class="line"> 如果<span class="title function_">then</span>()有返回结果，且结果是非<span class="title class_">Promise</span>对象，则<span class="title function_">then</span>()方法返回的<span class="title class_">Promise</span>对象状态为【resolved】，其值为【返回值】，即<span class="number">521</span>例如</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"> <span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//2. 返回结果是非 Promise 类型的对象</span></span><br><span class="line">       <span class="comment">// return 521;</span></span><br><span class="line">   ),<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   如果<span class="title function_">then</span>()有返回结果，且结果是<span class="title class_">Promise</span>对象，例如则其返回的<span class="title class_">Promise</span>的状态和值由返回的<span class="title class_">Promise</span>决定</span><br><span class="line">   <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  /<span class="number">3.</span> 返回结果是 <span class="title class_">Promise</span> 对象</span><br><span class="line">       <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">       <span class="comment">//     // resolve(&#x27;success&#x27;);</span></span><br><span class="line">       <span class="comment">//     reject(&#x27;error&#x27;);</span></span><br><span class="line">       <span class="comment">// &#125;);</span></span><br><span class="line">   ),<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">   &#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2023/08/04/flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/04/flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-flex是什么，为什么要学习flex，以及学习flex的好处"><a href="#一-flex是什么，为什么要学习flex，以及学习flex的好处" class="headerlink" title="一.flex是什么，为什么要学习flex，以及学习flex的好处"></a>一.flex是什么，为什么要学习flex，以及学习flex的好处</h2><p> 1.响应式布局：适应不同屏幕的大小和设备的布局。<br> 2.内容对齐和居中: 可以轻松地在主轴和交叉轴上对齐和居中元素，而无需使用繁琐的定位和浮动。</p><h2 id="二-以下是一些常用的-Flex-布局属性："><a href="#二-以下是一些常用的-Flex-布局属性：" class="headerlink" title="二.以下是一些常用的 Flex 布局属性："></a>二.以下是一些常用的 Flex 布局属性：</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>： 定义了项目的排列方向，可以是 row（水平排列）、column（垂直排列）、row-reverse（反向水平排列）或 column-reverse（反向垂直排列）。</span><br><span class="line"><span class="attribute">flex-wrap</span>： 定义项目是否换行，可以是 nowrap（不换行）、wrap（换行）或 wrap-reverse（反向换行）。</span><br><span class="line"><span class="attribute">flex-grow</span>： 定义项目的伸缩比例，决定了在剩余空间中的分配比例。</span><br><span class="line"><span class="attribute">flex-shrink</span>： 定义项目的收缩比例，决定了当空间不足时如何收缩。</span><br><span class="line"><span class="attribute">flex-basis</span>： 定义项目的初始大小。</span><br><span class="line"><span class="attribute">flex</span>： 是 <span class="attribute">flex-grow</span>、<span class="attribute">flex-shrink</span> 和 <span class="attribute">flex-basis</span> 的缩写。</span><br><span class="line"><span class="attribute">align-items</span>： 定义项目在交叉轴上的对齐方式。</span><br><span class="line"><span class="attribute">align-content</span>： 定义多行项目在交叉轴上的对齐方式。</span><br><span class="line"><span class="attribute">justify-content</span>： 定义项目在主轴上的对齐方式。   </span><br></pre></td></tr></table></figure><h2 id="三-调节flex子元素的大小flex-basis-amp-flex-grow"><a href="#三-调节flex子元素的大小flex-basis-amp-flex-grow" class="headerlink" title="三.调节flex子元素的大小flex-basis&amp;flex-grow"></a>三.调节flex子元素的大小flex-basis&amp;flex-grow</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">           <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.container</span> &#123;</span><br><span class="line">           <span class="attribute">display</span>: flex;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">5px</span> solid pink;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.item</span> &#123;</span><br><span class="line">           <span class="comment">/* 默认为1,如果为0就不缩小 */</span></span><br><span class="line">           <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">           <span class="comment">/* flex子元素的大小 */</span></span><br><span class="line">           <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="comment">/* 1000px - 5 * (2x) = 500px */</span></span><br><span class="line">           <span class="comment">/* x = 50px */</span></span><br><span class="line">           <span class="comment">/* 200px - 2 * 50px = 100px */</span></span><br><span class="line"></span><br><span class="line">           <span class="attribute">background</span>: skyblue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">/* 别人搜小2等份，我缩小1等份，所以我比别人大 */</span></span><br><span class="line">           <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="四-3-flex属性三合一"><a href="#四-3-flex属性三合一" class="headerlink" title="四.3-flex属性三合一"></a>四.3-flex属性三合一</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="flex容器基本概念"><a href="#flex容器基本概念" class="headerlink" title="flex容器基本概念"></a>flex容器基本概念</h3><!-- <div style="position: relative; padding-bottom: 56.25%; height: 0;">  <iframe src="//player.bilibili.com/player.html?aid=988812159&bvid=BV1A44y1Z7Bp&cid=927483369&page=1"          style="position: absolute; width: 100%; height: 100%; border: 0;"          allowfullscreen="true"></iframe></div> -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建springboot报错</title>
      <link href="/2023/07/20/%E5%88%9B%E5%BB%BAspringboot%E6%8A%A5%E9%94%99/"/>
      <url>/2023/07/20/%E5%88%9B%E5%BB%BAspringboot%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建springboot报错"><a href="#1-创建springboot报错" class="headerlink" title="1.创建springboot报错"></a>1.创建springboot报错</h2><p><img src="/./assets/image-20220327162821487.png" alt="image-20220327162821487"></p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p><img src="/./assets/image-20220327162947429.png" alt="image-20220327162947429"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>处理req中文乱码问题</title>
      <link href="/2023/07/20/%E5%A4%84%E7%90%86req%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/20/%E5%A4%84%E7%90%86req%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-处理req中文乱码问题"><a href="#1-处理req中文乱码问题" class="headerlink" title="1.处理req中文乱码问题"></a>1.处理req中文乱码问题</h3><p>1.先编码，转为字节数组。tomcat进行URL解码，默认字符集ISO_8859_1.</p><p>2.将字节数组转为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username  = <span class="keyword">new</span> <span class="title class_">String</span>(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//* GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了</span></span><br><span class="line">* 只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。</span><br></pre></td></tr></table></figure><p>3.Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8，但目前tomcat依赖只支持到7，所以需用本地的尝试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>海贼王路飞</title>
      <link href="/2023/05/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/05/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>#这是我的第一篇文章</p><!-- heco cl;hexo g;hexo d  三连 -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
